{"version":3,"sources":["index.js","index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/// <reference path=\"../typings/index.d.ts\"/>\nimport { BufferReader, BufferWriter } from './buffer-utils';\nimport { FIREHOSE_ENVELOPE } from './envelope-structure';\nimport * as uuid from 'node-uuid';\nimport { KinesisBridgeEnvelope } from './kinesis-bridge-envelope';\nexport class KinesisBridgeEnvelopeParser {\n    /**\n     * Parses a base64 encoded Kinesis Bridge envelope string payload\n     * @param base64Data\n     * @returns {*}\n     */\n    parseData(base64Data) {\n        const reader = new BufferReader(new Buffer(base64Data, 'base64'));\n        // Empty object with public properties\n        const envelope = new KinesisBridgeEnvelope();\n        envelope.headerVersion = reader.readIntLE(FIREHOSE_ENVELOPE.HEADER_VERSION);\n        envelope.timeUUID = uuid.unparse(reader.readBuffer(FIREHOSE_ENVELOPE.TIME_UUID));\n        envelope.sourceNameLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.SOURCE_NAME_LENGTH);\n        envelope.sourceName = reader.readString(envelope.sourceNameLength);\n        envelope.sourcePropertiesLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.SOURCE_PROPERTIES_LENGTH);\n        const serializedSourceProperties = reader.readString(envelope.sourcePropertiesLength);\n        if (serializedSourceProperties.length > 0) {\n            envelope.sourceProperties = JSON.parse(serializedSourceProperties);\n        }\n        else {\n            envelope.sourceProperties = {};\n        }\n        envelope.targetNameLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.TARGET_NAME_LENGTH);\n        envelope.targetName = reader.readString(envelope.targetNameLength);\n        envelope.targetPropertiesLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.TARGET_PROPERTIES_LENGTH);\n        envelope.targetProperties = JSON.parse(reader.readString(envelope.targetPropertiesLength));\n        envelope.contentLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.CONTENT_LENGTH);\n        envelope.contentBody = reader.readBuffer(envelope.contentLength);\n        return envelope;\n    }\n    encodeData(envelope) {\n        const data = {\n            sourceName: envelope.sourceName,\n            sourceProperties: JSON.stringify(envelope.sourceProperties),\n            targetName: envelope.targetName,\n            targetProperties: JSON.stringify(envelope.targetProperties),\n            contentBody: envelope.contentBody\n        };\n        // Loops through object and returns int of all values summed\n        const lengthSize = Object.keys(FIREHOSE_ENVELOPE).reduce((acc, current) => (acc + FIREHOSE_ENVELOPE[current]), 0);\n        // Loops through object and returns int of all value string lengths summed\n        const dataValuesSize = Object.keys(data).reduce((acc, current) => (acc + (data[current] === '{}' ? 0 : data[current].length)), 0);\n        // Creates buffer of the correct length\n        const nodeBuffer = Buffer.alloc(lengthSize + dataValuesSize);\n        const buffer = new BufferWriter(nodeBuffer);\n        // Wrapper function to write strings to buffer\n        const writeString = (str) => {\n            buffer.writeMultibyteNumLE(str.length, 2);\n            buffer.writeString(str, str.length);\n        };\n        const writeJson = (str) => {\n            if (str === '{}') {\n                buffer.writeMultibyteNumLE(0, 2);\n            }\n            else {\n                buffer.writeMultibyteNumLE(str.length, 2);\n                buffer.writeString(str, str.length);\n            }\n        };\n        buffer.writeIntLE(envelope.headerVersion, FIREHOSE_ENVELOPE.HEADER_VERSION);\n        const timeUUID = Buffer.alloc(FIREHOSE_ENVELOPE.TIME_UUID);\n        uuid.parse(envelope.timeUUID, timeUUID);\n        buffer.copyFrom(timeUUID, FIREHOSE_ENVELOPE.TIME_UUID);\n        writeString(data.sourceName);\n        writeJson(data.sourceProperties);\n        writeString(data.targetName);\n        writeJson(data.targetProperties);\n        buffer.writeIntLE(envelope.contentBody.length, FIREHOSE_ENVELOPE.CONTENT_LENGTH);\n        buffer.copyFrom(envelope.contentBody, envelope.contentBody.length);\n        return buffer.getBuffer().toString('base64');\n    }\n}\n","/// <reference path=\"../typings/index.d.ts\"/>\n\nimport { BufferReader, BufferWriter } from  './buffer-utils';\nimport { FIREHOSE_ENVELOPE } from './envelope-structure';\nimport * as uuid from 'node-uuid';\nimport { KinesisBridgeEnvelope } from './kinesis-bridge-envelope';\n\nexport class KinesisBridgeEnvelopeParser {\n\n    /**\n     * Parses a base64 encoded Kinesis Bridge envelope string payload\n     * @param base64Data\n     * @returns {*}\n     */\n    public parseData(base64Data: string): KinesisBridgeEnvelope {\n        const reader = new BufferReader(new Buffer(base64Data, 'base64'));\n\n        // Empty object with public properties\n        const envelope = new KinesisBridgeEnvelope();\n\n        envelope.headerVersion = reader.readIntLE(FIREHOSE_ENVELOPE.HEADER_VERSION);\n        envelope.timeUUID = uuid.unparse(reader.readBuffer(FIREHOSE_ENVELOPE.TIME_UUID));\n\n        envelope.sourceNameLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.SOURCE_NAME_LENGTH);\n        envelope.sourceName = reader.readString(envelope.sourceNameLength);\n\n        envelope.sourcePropertiesLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.SOURCE_PROPERTIES_LENGTH);\n\n        const serializedSourceProperties = reader.readString(envelope.sourcePropertiesLength);\n        if (serializedSourceProperties.length > 0) {\n            envelope.sourceProperties = JSON.parse(serializedSourceProperties);\n        } else {\n            envelope.sourceProperties = {};\n        }\n\n        envelope.targetNameLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.TARGET_NAME_LENGTH);\n        envelope.targetName = reader.readString(envelope.targetNameLength);\n\n        envelope.targetPropertiesLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.TARGET_PROPERTIES_LENGTH);\n        envelope.targetProperties = JSON.parse(reader.readString(envelope.targetPropertiesLength));\n\n        envelope.contentLength = reader.readMultibyteNumLE(FIREHOSE_ENVELOPE.CONTENT_LENGTH);\n        envelope.contentBody = reader.readBuffer(envelope.contentLength);\n\n        return envelope;\n    }\n\n    public encodeData(envelope: KinesisBridgeEnvelope): string {\n        const data = {\n            sourceName: envelope.sourceName,\n            sourceProperties: JSON.stringify(envelope.sourceProperties),\n            targetName: envelope.targetName,\n            targetProperties: JSON.stringify(envelope.targetProperties),\n            contentBody: envelope.contentBody\n        };\n\n        // Loops through object and returns int of all values summed\n        const lengthSize = Object.keys(FIREHOSE_ENVELOPE).reduce((acc, current) => (acc + FIREHOSE_ENVELOPE[current]), 0);\n\n        // Loops through object and returns int of all value string lengths summed\n        const dataValuesSize = Object.keys(data).reduce((acc, current) => (acc + (data[current] === '{}' ? 0 : data[current].length)) , 0);\n\n        // Creates buffer of the correct length\n        const nodeBuffer = Buffer.alloc(lengthSize + dataValuesSize);\n        const buffer = new BufferWriter(nodeBuffer);\n\n        // Wrapper function to write strings to buffer\n        const writeString = (str) => {\n            buffer.writeMultibyteNumLE(str.length, 2);\n            buffer.writeString(str, str.length);\n        };\n\n        const writeJson = (str) => {\n            if (str === '{}') {\n                buffer.writeMultibyteNumLE(0, 2);\n            } else {\n                buffer.writeMultibyteNumLE(str.length, 2);\n                buffer.writeString(str, str.length);\n            }\n        };\n\n        buffer.writeIntLE(envelope.headerVersion, FIREHOSE_ENVELOPE.HEADER_VERSION);\n\n        const timeUUID = Buffer.alloc(FIREHOSE_ENVELOPE.TIME_UUID);\n        uuid.parse(envelope.timeUUID, timeUUID);\n\n        buffer.copyFrom(timeUUID, FIREHOSE_ENVELOPE.TIME_UUID);\n\n        writeString(data.sourceName);\n        writeJson(data.sourceProperties);\n        writeString(data.targetName);\n        writeJson(data.targetProperties);\n\n        buffer.writeIntLE(envelope.contentBody.length, FIREHOSE_ENVELOPE.CONTENT_LENGTH);\n        buffer.copyFrom(envelope.contentBody, envelope.contentBody.length);\n\n        return buffer.getBuffer().toString('base64');\n    }\n\n}\n"]}